## 31. 下一个排列

<p>
实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须 _原地_ 修改，只允许使用额外常数空间。
</p>

```
示例 1：

输入：nums = [1,2,3]
输出：[1,3,2]

示例 2：

输入：nums = [3,2,1]
输出：[1,2,3]

示例 3：

输入：nums = [1,1,5]
输出：[1,5,1]

示例 4：

输入：nums = [1]
输出：[1]
```

> #### 提示： <br>
> 1 <= nums.length <= 100
>
> 0 <= nums[i] <= 100

<p style="font-size: 14px">
来源：力扣（LeetCode） <br>
链接：https://leetcode-cn.com/problems/next-permutation <br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
</p>

##### 方法：
> 解这道题之前先了解下字典序:
> 
> 字典序（dictionary order），又称 字母序（alphabetical order），原意是表示英文单词在字典中的先后顺序，在计算机领域中扩展成两个任意字符串的大小关系。
> 取决于两个字符串从左到右第一个不同字符的 ASCII 值的大小关系。
> 示例：1 2 3的全排列如下：
> 
> 1 2 3 | 1 3 2 | 2 1 3 | 2 3 1 | 3 1 2 | 3 2 1

那么什么是字典序法呢？
从上面的全排列也可以看出来了，从左往右依次增大，对这就是字典序法。可是如何用算法来实现字典序法全排列呢？

我们再来看一段文字描述：（用字典序法找158476531的下一个排列）

如果当前排列是158476531，找它的下一个排列的方法是:
- 从这个序列中从右至左找第一个左邻小于右邻的数；
- 如果找不到，则所有排列求解完成，如果找得到则说明排列未完成；
- 本例中将找到47，计4所在的位置为i,找到后不能直接将47位置互换，而又要从右到左到第一个比4大的数；
- 本例找到的数是5，其位置计为j，将i与j所在元素交换158576431；
- 然后将i+1至最后一个元素从小到大排序得到158513467，这就是158476531的下一个排列。
  <img src="https://assets.leetcode-cn.com/solution-static/31/31.gif" alt="下一个排列">

**_了解了字典序法之后，本题就很明了了，使用字典序法解决：
如果数组只有一个数，直接返回；如果找不到一个左邻小于右邻的数，说明为排列完成，此时数组为降序，直接数组升序；否则按照字典序法来即可。_**

```
const nextPermutation = function(nums) {
    if (nums.length === 1) return
    let loop = nums.length - 2
    while (loop >= 0 && nums[loop] >= nums[loop + 1]) { // 找到第一个左邻小于右邻的数的索引
        loop--
    }
    if (loop >= 0) { // loop>=0代表找到了左邻小于右邻的数
        let n = nums.length - 1
        while (n >= 0 && nums[n] <= nums[loop]) { // 从右到左查找大于nums[i]的值并交换位置
            n--
        }
        [nums[loop], nums[n]] = [nums[n], nums[loop]]
    }
    // 无论是否排列完成均进行升序：完成排列，说明数组为降序，则loop=-1，从nums[0]开始；未完成则从nums[loop + 1]开始；
    let l = loop + 1
    let r = nums.length - 1
    while (l < r) {
        [nums[l], nums[r]] = [nums[r], nums[l]]
        l++
        r--
    }
}
```
