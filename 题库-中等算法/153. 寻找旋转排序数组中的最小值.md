## 153. 寻找旋转排序数组中的最小值

<p>
已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：

- 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
- 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]

注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。
</p>

```
示例 1：

输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。

示例 2：

输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。

示例 3：

输入：nums = [11,13,15,17]
输出：11
解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。
```

> #### 提示： <br>
> n == nums.length
>
> 1 <= n <= 5000
>
> -5000 <= nums[i] <= 5000
> 
> nums 中的所有整数 互不相同
> 
> nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转

进阶：你可以实现时间复杂度为 O(logN) 的解决方案吗？

<p style="font-size: 14px">
来源：力扣（LeetCode） <br>
链接：https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array <br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
</p>

##### 方法：
- 二分查找    
  **_转移旋转后是从右侧开始位小值，所以二分法注意要拿右侧的值和mid作比较。类似的题目有：
  [寻找峰值](162.%20寻找峰值.md)，[搜索旋转排序数组](33.%20搜索旋转排序数组.md)，[搜索旋转排序数组 II](81.%20搜索旋转排序数组%20II.md)_**
  
            mid
             /
            /    /r
           /    /
          /    /
        l/    /
            最小值

```js
const findMin = function(nums) {
    let l = 0, r = nums.length - 1, mid = 0
    while (l < r) {
        mid = Math.floor((l + r) / 2)
        if (nums[r] < nums[mid]) {
            l = mid + 1
        } else {
            r = mid
        }
    }
    return nums[r]
}
```
